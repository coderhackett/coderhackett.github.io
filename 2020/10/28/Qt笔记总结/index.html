<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Qt笔记总结 | 加班猿</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.8.2/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.2.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2020-10-27T16:00:00.000Z" id="date"> 2020-10-28</time></span><br><span>updated:<time datetime="2020-11-14T14:27:20.781Z" id="updated"> 2020-11-14</time></span></div><h1>Qt笔记总结</h1><hr></div><div id="post-content"><p><img src="https://img-blog.csdnimg.cn/20201028200839229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div align = 'right'>作者：hackett</div>

<div align = 'right'>微信公众号：加班猿</div>



<h2 id="一、常用控件"><a href="#一、常用控件" class="headerlink" title="一、常用控件"></a>一、常用控件</h2><h3 id="按钮类"><a href="#按钮类" class="headerlink" title="按钮类"></a>按钮类</h3><p>QPushButton</p>
<p>QtoolButton</p>
<p>QRadioButton</p>
<h3 id="item"><a href="#item" class="headerlink" title="item"></a>item</h3><p>QListWidget</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>QStackWidget</p>
<p>QWidget</p>
<p>QFrame</p>
<h3 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h3><p>QComboBox</p>
<p>QLineEdit</p>
<p>QTextEdit</p>
<h3 id="显示类"><a href="#显示类" class="headerlink" title="显示类"></a>显示类</h3><p>QLabel</p>
<p><strong>setOpenExternalLinks()设置为true自动打开，false要打开链接需要捕捉linkActivated()信号</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//显示普通文本字符串</span><br>QLable *label = <span class="hljs-keyword">new</span> QLable;<br>label-&gt;setText(“Hello, World!”);<br><span class="hljs-comment">//显示HTML格式的字符串</span><br>QLabel * label = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-keyword">this</span>);<br>label -&gt;setText(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>label -&gt;setText(<span class="hljs-string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;</span><br><span class="hljs-string">百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);<br>label -&gt;setOpenExternalLinks(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">QLabel * label = <span class="hljs-keyword">new</span> QLabel(<span class="hljs-keyword">this</span>);<br>label -&gt;setText(<span class="hljs-string">&quot;Hello, World&quot;</span>);<br>label -&gt;setText(<span class="hljs-string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;</span><br><span class="hljs-string">百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);<br><span class="hljs-comment">// label-&gt;setOpenExternalLinks(true);</span><br>connect(label, &amp;QLabel::linkActivated, <br><span class="hljs-keyword">this</span>, &amp;MyWidget::slotOpenUrl);<br><br><span class="hljs-comment">//槽函数	</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyWidget::slotOpenUrl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;link)</span></span><br><span class="hljs-function"></span>&#123;<br>    QDesktopServices::openUrl(QUrl(link));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>QProcessBar</p>
<p>QMessageBox</p>
<h2 id="二、信号与槽"><a href="#二、信号与槽" class="headerlink" title="二、信号与槽"></a>二、信号与槽</h2><h3 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h3><p>信号槽，实际就是观察者模式。<strong>当某个事件发生之后，它就会发出一个信号（signal）将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。当信号发出时，被连接的槽函数会自动被回调。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>、connect(sender, signal, receiver, slot);<br></code></pre></td></tr></table></figure>

<ul>
<li>sender：发送信号的对象</li>
<li>signal：发送对象发出的信号</li>
<li>receiver：接收信号的对象</li>
<li>slot：接收对象在接收到信号之后所需要调用的函数</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* &amp;b1: 信号发出者，指针类型</span><br><span class="hljs-comment">* &amp;QPushButton::pressed：处理的信号	(&amp;发送者的类名::信号名字)</span><br><span class="hljs-comment">* this: 信号接收者</span><br><span class="hljs-comment">* &amp;MainWidget::close：槽函数，信号处理函数 (&amp;接收的类名::槽函数名字)</span><br><span class="hljs-comment">*/</span><br>connect(&amp;b1, &amp;QPushButton::pressed, <span class="hljs-keyword">this</span>, &amp;MainWidget::close);<br></code></pre></td></tr></table></figure>

<h3 id="自定义信号槽"><a href="#自定义信号槽" class="headerlink" title="自定义信号槽"></a>自定义信号槽</h3><h4 id="自定义信号槽需要注意的事项"><a href="#自定义信号槽需要注意的事项" class="headerlink" title="自定义信号槽需要注意的事项"></a>自定义信号槽需要注意的事项</h4><ul>
<li><p><strong>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</strong></p>
</li>
<li><p><strong>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</strong></p>
</li>
<li><p><strong>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</strong></p>
</li>
<li><p><strong>使用 emit 在恰当的位置发送信号；</strong></p>
</li>
<li><p><strong>使用QObject::connect()函数连接信号和槽。</strong></p>
</li>
<li><p><strong>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 自定义槽，普通函数的用法</span><br><span class="hljs-comment">* Qt5：任意的成员函数，普通全局函数，静态函数</span><br><span class="hljs-comment">* 槽函数需要和信号一致（参数，返回值）</span><br><span class="hljs-comment">* 由于信号都是没有返回值，所以，槽函数一定没有返回值</span><br><span class="hljs-comment">*/</span><br>connect(b2, &amp;QPushButton::released, <span class="hljs-keyword">this</span>, &amp;MainWidget::mySlot);<br></code></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>C++11中的Lambda表达式<strong>用于定义并创建匿名的函数对象</strong>。</p>
<p>基本构成：[函数对象参数](操作符重载函数参数)mutable或exception -&gt;返回值{函数体}</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/57ad00546224b5d0b2d1d004c4cb31e1.png"></p>
<p>1、函数对象参数：</p>
<p>[ ] 标识一个<strong>Lambda的开始</strong>，这部分必须存在，<strong>不能省略</strong>。</p>
<ul>
<li><p> 空，没有任何函数对象参数</p>
</li>
<li><p>=，<strong>值传递方式</strong>（作用范围：所有可见的局部变量以及所在类的this）</p>
</li>
<li><p>&amp;，<strong>引用传递方式</strong>（作用范围：所有可见的局部变量以及所在类的this）</p>
</li>
<li><p>this，函数体内可以可以使用<strong>Lambda所在类</strong>中的成员变量</p>
</li>
<li><p>a，把a按值进行传递（默认为const不可修改，可添加mutable修饰符修改）</p>
</li>
<li><p>&amp;b，把b按引用进行传递</p>
</li>
<li><p>&amp;，a，b，除a和b进行值传递，其他参数按引用进行传递</p>
</li>
</ul>
<p>2、操作符重载函数参数：</p>
<p>标识重载的()操作符的参数，没有参数时，这部分可以省略。</p>
<p>3、可修改标示符：</p>
<p>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p>
<p>4、错误抛出标示符：</p>
<p>exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)</p>
<p>5、函数返回值：</p>
<p>-&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
<p>6、函数体：    </p>
<p>  {}，标识函数的实现，这部分<strong>不能省略</strong>，但函数体可以为空。</p>
<p>   ​     </p>
<h2 id="三、Qt窗口系统"><a href="#三、Qt窗口系统" class="headerlink" title="三、Qt窗口系统"></a>三、Qt窗口系统</h2><h3 id="1、坐标体系"><a href="#1、坐标体系" class="headerlink" title="1、坐标体系"></a>1、坐标体系</h3><p>以左上角为原点，X向右增加，Y向下增加。</p>
<p><img src="https://img-blog.csdnimg.cn/20201029110721546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7PAwd2gB-1603886732744)(https://raw.githubusercontent.com/CodingEmbedded/cloudimg/master/image/20201028185754.png)]"></p>
<h3 id="2、QWidget"><a href="#2、QWidget" class="headerlink" title="2、QWidget"></a>2、QWidget</h3><p>所有窗口及窗口控件都是从QWidget直接或间接派生出来的。</p>
<ol>
<li><p>对象模型</p>
<ul>
<li><p>Qt创建对象的时候会提供一个Parent对象指针</p>
<p>  <strong>在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</strong></p>
</li>
<li><p>QWidget是能够在屏幕上显示的一切组件的父类</p>
<p>  <strong>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件，也可以自己删除子对象，它们会自动从其父对象列表中删除。</strong></p>
</li>
<li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的</p>
</li>
<li><p>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3、QMainWindow"><a href="#3、QMainWindow" class="headerlink" title="3、QMainWindow"></a>3、QMainWindow</h3><p>QMainWindow是一个为用户提供主窗口程序的类，包含<strong>一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201029110743123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1、菜单栏</p>
<ul>
<li><p>创建菜单栏，通过QMainWindow类的menubar() 函数获取主窗口菜单栏指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QMenuBar *	<span class="hljs-title">menuBar</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>创建菜单，调用QMenu的成员函数addMenu() 来添加菜单</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QAction* <span class="hljs-title">addMenu</span><span class="hljs-params">(QMenu * menu)</span></span><br><span class="hljs-function">QMenu* <span class="hljs-title">addMenu</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp; title)</span></span><br><span class="hljs-function">QMenu* <span class="hljs-title">addMenu</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QIcon &amp; icon, <span class="hljs-keyword">const</span> QString &amp; title)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>创建菜单项，调用QMenu的成员函数addAction() 来添加菜单项</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QAction* <span class="hljs-title">activeAction</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp; text)</span></span><br><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QIcon &amp; icon, <span class="hljs-keyword">const</span> QString &amp; text)</span></span><br><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp; text, <span class="hljs-keyword">const</span> QObject * receiver,</span></span><br><span class="hljs-function"><span class="hljs-params"> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * member, <span class="hljs-keyword">const</span> QKeySequence &amp; shortcut = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">QAction* <span class="hljs-title">addAction</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QIcon &amp; icon, <span class="hljs-keyword">const</span> QString &amp; text, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QObject * receiver, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * member, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QKeySequence &amp; shortcut = <span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>2、工具栏</p>
<ul>
<li><p>直接调用QMainWindow类的addToolBar() 函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</p>
</li>
<li><p>n 插入属于工具条的动作，即在工具条上添加操作。通过QToolBar类的addAction() 函数添加。</p>
</li>
<li><p>n 工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Qt::LeftToolBarArea		//停靠在左侧</span><br><span class="hljs-comment">Qt::RightToolBarArea		//停靠在右侧</span><br><span class="hljs-comment">Qt::TopToolBarArea		//停靠在顶部</span><br><span class="hljs-comment">Qt::BottomToolBarArea   	//停靠在底部</span><br><span class="hljs-comment">Qt::AllToolBarAreas		//以上四个位置都可停靠</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*使用setAllowedAreas（）函数指定停靠区域*/</span><br>setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);<br><span class="hljs-comment">/*使用setMoveable（）函数设定工具栏的可移动性*/</span><br>setMoveable(<span class="hljs-literal">false</span>);<span class="hljs-comment">//工具条不可移动, 只能停靠在初始化的位置上</span><br><br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>3、状态栏</p>
<ul>
<li><p>派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//添加小部件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addWidget</span><span class="hljs-params">(QWidget * widget, <span class="hljs-keyword">int</span> stretch = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-comment">//插入小部件</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span>	<span class="hljs-title">insertWidget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, QWidget * widget, <span class="hljs-keyword">int</span> stretch = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"><span class="hljs-comment">//删除小部件</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeWidget</span><span class="hljs-params">(QWidget * widget)</span></span><br></code></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="4、对话框QDialog"><a href="#4、对话框QDialog" class="headerlink" title="4、对话框QDialog"></a>4、对话框QDialog</h3><p>Qt 中使用QDialog类实现对话框。</p>
<p><strong>对话框分为模态对话框和非模态对话框。</strong></p>
<ul>
<li><p>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。</p>
<p>  模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</p>
</li>
<li><p>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p>
</li>
</ul>
<p>1、标准对话框</p>
<p>Qt 的内置对话框大致分为以下几类：</p>
<ul>
<li><p>QColorDialog：    选择颜色；</p>
</li>
<li><p>QFileDialog：    选择文件或者目录；</p>
</li>
<li><p>QFontDialog：    选择字体；</p>
</li>
<li><p>QInputDialog：    允许用户输入一个值，并将其值返回；</p>
</li>
<li><p>QMessageBox：    模态对话框，用于显示信息、询问问题等；</p>
</li>
<li><p>QPageSetupDialog：  为打印机提供纸张相关的选项；</p>
</li>
<li><p>QPrintDialog：    打印机配置；</p>
</li>
<li><p>QPrintPreviewDialog：打印预览；</p>
</li>
<li><p>QProgressDialog：  显示操作过程。</p>
</li>
</ul>
<p>2、自定义消息框</p>
<p>Qt 支持模态对话框和非模态对话框。</p>
<p>模态与非模态的实现：</p>
<ul>
<li><p>使用QDialog::exec()实现应用程序级别的模态对话框</p>
</li>
<li><p>使用QDialog::open()实现窗口级别的模态对话框</p>
</li>
<li><p>使用QDialog::show()实现非模态对话框。</p>
</li>
</ul>
<p>3、模态对话框</p>
<p>下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::open</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QDialog dialog;<br>    dialog.setWindowTitle(tr(<span class="hljs-string">&quot;Hello, dialog!&quot;</span>));<br>    dialog.exec();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、非模态对话框</p>
<p>下面我们试着将exec()修改为show()，看看非模态对话框：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::open</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QDialog <span class="hljs-title">dialog</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    dialog.setWindowTitle(tr(<span class="hljs-string">&quot;Hello, dialog!&quot;</span>));<br>    dialog.show();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是事与愿违？对话框竟然一闪而过！这是因为，<strong>show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。</strong>注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::open</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QDialog *dialog = <span class="hljs-keyword">new</span> QDialog;<br>    dialog-&gt;setWindowTitle(tr(<span class="hljs-string">&quot;Hello, dialog!&quot;</span>));<br>    dialog-&gt;show();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你足够细心，应该发现上面的代码是有问题的：dialog 存在内存泄露！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p>
<p>不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::open</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QDialog *dialog = <span class="hljs-keyword">new</span> QDialog;<br>    dialog-&gt;setAttribute(Qt::WA_DeleteOnClose);<br>    dialog-&gt;setWindowTitle(tr(<span class="hljs-string">&quot;Hello, dialog!&quot;</span>));<br>    dialog-&gt;show();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>setAttribute()函数设置对话框关闭时，自动销毁对话框。</strong></p>
<p>1、消息对话框</p>
<p>QMessageBox用于显示消息提示。我们一般会使用其提供的几个 static 函数：</p>
<ul>
<li><p>显示关于对话框。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">about</span><span class="hljs-params">(QWidget * parent, <span class="hljs-keyword">const</span> QString &amp; title, <span class="hljs-keyword">const</span> QString &amp; text)</span></span><br></code></pre></td></tr></table></figure>

<p>  这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p>
</li>
<li><p>显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aboutQt</span><span class="hljs-params">(QWidget * parent, <span class="hljs-keyword">const</span> QString &amp; title = QString())</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>显示严重错误对话框。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">critical</span><span class="hljs-params">(QWidget * parent, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; title, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; text, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButtons buttons = Ok, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButton defaultButton = NoButton)</span></span><br></code></pre></td></tr></table></figure>

<p>  这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。</p>
</li>
<li><p>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">information</span><span class="hljs-params">(QWidget * parent, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; title, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; text, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButtons buttons = Ok, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButton defaultButton = NoButton)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">question</span><span class="hljs-params">(QWidget * parent,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; title, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; text, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButtons buttons = StandardButtons( Yes | No ), </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButton defaultButton = NoButton)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">StandardButton <span class="hljs-title">warning</span><span class="hljs-params">(QWidget * parent, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; title, </span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span> QString &amp; text, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButtons buttons = Ok, </span></span><br><span class="hljs-function"><span class="hljs-params">StandardButton defaultButton = NoButton)</span></span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>2、标准文件对话框</p>
<p>QFileDialog，也就是文件对话框。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">openAction = <span class="hljs-keyword">new</span> QAction(QIcon(<span class="hljs-string">&quot;:/images/file-open&quot;</span>),<br> tr(<span class="hljs-string">&quot;&amp;Open...&quot;</span>), <span class="hljs-keyword">this</span>);<br>openAction-&gt;setShortcuts(QKeySequence::Open);<br>openAction-&gt;setStatusTip(tr(<span class="hljs-string">&quot;Open an existing file&quot;</span>));<br><br>saveAction = <span class="hljs-keyword">new</span> QAction(QIcon(<span class="hljs-string">&quot;:/images/file-save&quot;</span>), <br>tr(<span class="hljs-string">&quot;&amp;Save...&quot;</span>), <span class="hljs-keyword">this</span>);<br>saveAction-&gt;setShortcuts(QKeySequence::Save);<br>saveAction-&gt;setStatusTip(tr(<span class="hljs-string">&quot;Save a new file&quot;</span>));<br><br>QMenu *file = menuBar()-&gt;addMenu(tr(<span class="hljs-string">&quot;&amp;File&quot;</span>));<br>file-&gt;addAction(openAction);<br>file-&gt;addAction(saveAction);<br><br>QToolBar *toolBar = addToolBar(tr(<span class="hljs-string">&quot;&amp;File&quot;</span>));<br>toolBar-&gt;addAction(openAction);<br>toolBar-&gt;addAction(saveAction);<br><br>textEdit = <span class="hljs-keyword">new</span> QTextEdit(<span class="hljs-keyword">this</span>);<br>setCentralWidget(textEdit);<br></code></pre></td></tr></table></figure>

<p>使用connect()函数，为这两个QAction对象添加响应的动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">connect(openAction, &amp;QAction::triggered, <br><span class="hljs-keyword">this</span>, &amp;MainWindow::openFile);<br>connect(saveAction, &amp;QAction::triggered, <br><span class="hljs-keyword">this</span>, &amp;MainWindow::saveFile);<br></code></pre></td></tr></table></figure>

<p>下面是最主要的openFile()和saveFile()这两个函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//打开文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::openFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QString path = QFileDialog::getOpenFileName(<span class="hljs-keyword">this</span>,<br>               tr(<span class="hljs-string">&quot;Open File&quot;</span>), <span class="hljs-string">&quot;.&quot;</span>, tr(<span class="hljs-string">&quot;Text Files(*.txt)&quot;</span>));<br>    <span class="hljs-keyword">if</span>(!path.isEmpty()) <br>&#123;<br>        <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;<br>        <span class="hljs-keyword">if</span> (!file.open(QIODevice::ReadOnly | QIODevice::Text)) <br>&#123;<br>            QMessageBox::warning(<span class="hljs-keyword">this</span>, tr(<span class="hljs-string">&quot;Read File&quot;</span>),<br>                         tr(<span class="hljs-string">&quot;Cannot open file:\n%1&quot;</span>).arg(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-function">QTextStream <span class="hljs-title">in</span><span class="hljs-params">(&amp;file)</span></span>;<br>        textEdit-&gt;setText(in.readAll());<br>        file.close();<br>    &#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>        QMessageBox::warning(<span class="hljs-keyword">this</span>, tr(<span class="hljs-string">&quot;Path&quot;</span>),<br>                             tr(<span class="hljs-string">&quot;You did not select any file.&quot;</span>));<br>     &#125;<br>&#125;<br><br><span class="hljs-comment">//保存文件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MainWindow::saveFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QString path = QFileDialog::getSaveFileName(<span class="hljs-keyword">this</span>,<br>               tr(<span class="hljs-string">&quot;Open File&quot;</span>), <span class="hljs-string">&quot;.&quot;</span>, tr(<span class="hljs-string">&quot;Text Files(*.txt)&quot;</span>));<br>    <span class="hljs-keyword">if</span>(!path.isEmpty()) <br>&#123;<br>        <span class="hljs-function">QFile <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;<br>        <span class="hljs-keyword">if</span> (!file.open(QIODevice::WriteOnly | QIODevice::Text)) <br>&#123;<br>            QMessageBox::warning(<span class="hljs-keyword">this</span>, tr(<span class="hljs-string">&quot;Write File&quot;</span>),<br>                         tr(<span class="hljs-string">&quot;Cannot open file:\n%1&quot;</span>).arg(path));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-function">QTextStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;file)</span></span>;<br>        out &lt;&lt; textEdit-&gt;toPlainText();<br>        file.close();<br>    &#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>        QMessageBox::warning(<span class="hljs-keyword">this</span>, tr(<span class="hljs-string">&quot;Path&quot;</span>),<br>                             tr(<span class="hljs-string">&quot;You did not select any file.&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QString <span class="hljs-title">getOpenFileName</span><span class="hljs-params">(QWidget * parent = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> QString &amp; caption = QString(),</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> QString &amp; dir = QString(),</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">const</span> QString &amp; filter = QString(),</span></span><br><span class="hljs-function"><span class="hljs-params">                        QString * selectedFilter = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                        Options options = <span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>六个参数分别是：</p>
<ul>
<li><p>parent：父窗口</p>
</li>
<li><p>caption：对话框标题</p>
</li>
<li><p>dir：对话框打开时的默认目录</p>
<p>  “.” 代表程序运行目录</p>
<p>  “/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等</p>
</li>
<li><p>filter：过滤器。</p>
<p>  我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件</p>
</li>
<li><p>selectedFilter：默认选择的过滤器</p>
</li>
<li><p>options：对话框的一些参数设定</p>
<p>  比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来</p>
</li>
</ul>
<h2 id="四、布局管理器"><a href="#四、布局管理器" class="headerlink" title="四、布局管理器"></a>四、布局管理器</h2><p>Qt提供了两种组件定位机制：<strong>绝对定位和布局定位。</strong></p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</p>
<p>如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。</p>
<h3 id="布局定位"><a href="#布局定位" class="headerlink" title="布局定位"></a>布局定位</h3><p>只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。</p>
<p>Qt 提供的布局中以下三种是我们最常用的：</p>
<ol>
<li>QHBoxLayout：按照水平方向从左到右布局；</li>
<li>QVBoxLayout：按照竖直方向从上到下布局；</li>
<li>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</li>
</ol>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>UI的控件和自定义控件的父类（基类）要一样</p>
<p>选中UI控件 -&gt; 提升</p>
<h2 id="五、消息机制和事件"><a href="#五、消息机制和事件" class="headerlink" title="五、消息机制和事件"></a>五、消息机制和事件</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>Qt 中所有事件类都继承于QEvent</strong></p>
<p><strong>event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数</strong>（event handler）</p>
<p>在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如：</p>
<ul>
<li><p>keyPressEvent()</p>
</li>
<li><p>keyReleaseEvent()</p>
</li>
<li><p>mouseDoubleClickEvent()</p>
</li>
<li><p>mouseMoveEvent()</p>
</li>
<li><p>mousePressEvent()</p>
</li>
<li><p>mouseReleaseEvent() 等。</p>
</li>
</ul>
<p>这些函数都是 protected virtual 的，也就是说我们可以在<strong>子类中重新实现</strong>这些函数。下面来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventLabel</span> :</span> <span class="hljs-keyword">public</span> QLabel<br>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span>;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventLabel::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;setText(QString(<span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;Move: (%1, %2)</span><br><span class="hljs-string">&lt;/h1&gt;&lt;/center&gt;&quot;</span>).arg(QString::number(event-&gt;x()),<br>            QString::number(event-&gt;y())));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventLabel::mousePressEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;setText(QString(<span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)</span><br><span class="hljs-string">&lt;/h1&gt;&lt;/center&gt;&quot;</span>).arg(QString::number(event-&gt;x()),<br>                QString::number(event-&gt;y())));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EventLabel::mouseReleaseEvent</span><span class="hljs-params">(QMouseEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    QString msg;<br>    msg.<span class="hljs-built_in">sprintf</span>(<span class="hljs-string">&quot;&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;&quot;</span>,<br>                event-&gt;x(), event-&gt;y());<br>    <span class="hljs-keyword">this</span>-&gt;setText(msg);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br> <br>    EventLabel *label = <span class="hljs-keyword">new</span> EventLabel;<br>    label-&gt;setWindowTitle(<span class="hljs-string">&quot;MouseEvent Demo&quot;</span>);<br>    label-&gt;resize(<span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>    label-&gt;show();<br> <br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>EventLabel继承了QLabel，重写了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。</p>
<p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p>
<p>为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？</p>
<p><strong>这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</strong></p>
<p>在构造函数里面设置label-&gt;setMouseTracking(true);即可</p>
<h3 id="event"><a href="#event" class="headerlink" title="event()"></a>event()</h3><p><strong>event()函数主要用于事件的分发</strong></p>
<p>例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CustomWidget::event</span><span class="hljs-params">(QEvent *e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;type() == QEvent::KeyPress) &#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(e);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;<br>            qDebug() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QWidget::event(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型:</p>
<ul>
<li> <strong>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件</strong></li>
<li> <strong>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播</strong></li>
</ul>
<p><strong>event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本</strong></p>
<h3 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h3><p>有时候，对象需要查看、甚至要拦截发送到另外对象的事件。</p>
<p>QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">QObject::eventFilter</span> <span class="hljs-params">( QObject * watched, QEvent * event )</span></span>;<br></code></pre></td></tr></table></figure>

<p>这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，<strong>不想让它继续转发，就返回 true，否则返回 false。</strong>事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p>
<p>上面QWidget组件中event()函数监听 tab 键的按下修改为使用<strong>事件过滤器的版本</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FilterObject::eventFilter</span><span class="hljs-params">(QObject *object, QEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (object == target &amp;&amp; event-&gt;type() == QEvent::KeyPress) <br>&#123;<br>        QKeyEvent *keyEvent = <span class="hljs-keyword">static_cast</span>&lt;QKeyEvent *&gt;(event);<br>        <span class="hljs-keyword">if</span> (keyEvent-&gt;key() == Qt::Key_Tab) &#123;<br>            qDebug() &lt;&lt; <span class="hljs-string">&quot;You press tab.&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color = red size = 4><strong>注意:事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></font></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Qt</strong> <strong>的事件处理，实际上是有五个层次：</strong></p>
<ol>
<li>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</li>
</ol>
<h2 id="六、绘图和绘图设备"><a href="#六、绘图和绘图设备" class="headerlink" title="六、绘图和绘图设备"></a>六、绘图和绘图设备</h2><h3 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h3><p><strong>QPainter</strong>用来执行绘制的操作；<strong>QPaintDevice</strong>是一个二维空间的抽象，<strong>QPaintEngine</strong>提供了画笔（QPainter）在不同的设备上进行绘制的统一的接口</p>
<p><img src="https://img-blog.csdnimg.cn/20201029110808861.png#pic_center" alt="在这里插入图片描述"></p>
<p>上面的示意图告诉我们，<font color = red size = 4><strong>Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯（也就是翻译QPainter的指令）。</strong></font></p>
<p>下面我们通过一个实例来介绍QPainter的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaintedWidget</span> :</span> <span class="hljs-keyword">public</span> QWidget<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">public</span>:<br>    PaintedWidget(QWidget *parent = <span class="hljs-number">0</span>);<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意我们重写了QWidget的paintEvent()函数。接下来就是PaintedWidget的源代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">PaintedWidget::PaintedWidget(QWidget *parent) :<br>    QWidget(parent)<br>&#123;<br>    resize(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br>    setWindowTitle(tr(<span class="hljs-string">&quot;Paint Demo&quot;</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PaintedWidget::paintEvent</span><span class="hljs-params">(QPaintEvent *)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    painter.drawLine(<span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">650</span>, <span class="hljs-number">500</span>);<br>    painter.setPen(Qt::red);<br>    painter.drawRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">400</span>);<br>    painter.setPen(QPen(Qt::green, <span class="hljs-number">5</span>));<br>    painter.setBrush(Qt::blue);<br>    painter.drawEllipse(<span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">400</span>, <span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造函数中，我们仅仅设置了窗口的大小和标题。而paintEvent()函数则是绘制的代码。</p>
<h3 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h3><p><strong>绘图设备是指继承QPainterDevice的子类。</strong></p>
<p>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用 QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</p>
<p>QPixmap：和平台无关，针对屏幕进行了优化了，不能对图片进行修改</p>
<p>QImage：和平台无关，在线程中绘图，可以对图片进行优化</p>
<p>QPicture：保存绘图的状态（二进制文件）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>、QPixmap -&gt; QImage<br><br>QPixmap a；<br><br>a.toImage();<br><br><span class="hljs-number">2</span>、QImage -&gt; QPixmap<br><br>QImage b;<br><br>QPixmap::fromImage(b);<br><br><span class="hljs-number">3</span>、QPainter<br><br>QPainter p;<br><br>QPicture pic;<br><br>p.begin(&amp;pic);<br><br><span class="hljs-comment">//绘图动作</span><br><br>p.end();<br><br>pic.save(<span class="hljs-string">&quot;路径&quot;</span>);<br><br><span class="hljs-number">4</span>、加载图片<br><br>QPicture temp;<br><br>temp.load(<span class="hljs-string">&quot;路径&quot;</span>);<br></code></pre></td></tr></table></figure>



<h3 id="不规则窗口"><a href="#不规则窗口" class="headerlink" title="不规则窗口"></a>不规则窗口</h3><p>1、给窗口画一张背景图</p>
<p>2、去表框</p>
<p>3、设定属性（背景透明）</p>
<p>4、移动坐标是<strong>相对于屏幕</strong>而言</p>
<h2 id="七、文件系统"><a href="#七、文件系统" class="headerlink" title="七、文件系统"></a>七、文件系统</h2><p> I/O 设备的类图（Qt5）：</p>
<p><img src="https://img-blog.csdnimg.cn/20201029110820891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>QIODevice：所有 I/O 设备类的父类，提供了字节块读写的通用操作以及基本接口；</li>
<li>QFileDevice：Qt5新增加的类，提供了有关文件操作的通用实现。</li>
<li>QFlie：访问本地文件或者嵌入资源；</li>
<li>QTemporaryFile：创建和访问本地文件系统的临时文件；</li>
<li>QBuffer：读写QbyteArray, 内存文件；</li>
<li>QProcess：运行外部程序，处理进程间通讯；</li>
<li>QAbstractSocket：所有套接字类的父类；</li>
<li>QTcpSocket：TCP协议网络数据传输；</li>
<li>QUdpSocket：传输 UDP 报文；</li>
<li>QSslSocket：使用 SSL/TLS 传输数据；</li>
</ul>
<p><strong>QFile提供了从文件中读取和写入数据的能力。</strong></p>
<p><strong>我们通常会将文件路径作为参数传给QFile的构造函数。不过也可以在创建好对象最后，使用setFileName()来修改</strong></p>
<p><strong>我们可以使用QDataStream或QTextStream类来读写文件，也可以使用QIODevice类提供的read()、readLine()、readAll()以及write()这样的函数。</strong>值得注意的是，<strong>有关文件本身的信息，比如文件名、文件所在目录的名字等，则是通过QFileInfo获取</strong>。</p>
<p>QFileInfo有很多类型的函数，举一些常用例子。比如：</p>
<ul>
<li>isDir()检查该文件是否是目录；</li>
<li>isExecutable()  检查该文件是否是可执行文件等。</li>
<li>baseName()  可以直接获得文件名；</li>
<li>completeBaseName()  获取完整的文件名</li>
<li>suffix()  则直接获取文件后缀名。</li>
<li>completeSuffix()  获取完整的文件后缀</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span>、QFile file;<br><br>file.setFileName();<br><br>file.open();<br><br>file.write();<br><br>file.read();<br><br>file.close();<br><br><span class="hljs-number">2</span>、QFileInfo info;<br><br>info.size();<br><br>info.fileName();<br><br><br><br>QDataStream：二进制方式<br><br>QTextStream：文本方式（指定编码）<br><br>QBuffer：内存文件（内容放在内存）<br></code></pre></td></tr></table></figure>

<h2 id="八、Socket通信"><a href="#八、Socket通信" class="headerlink" title="八、Socket通信"></a>八、Socket通信</h2><p>Qt中提供的所有的Socket类都是非阻塞的。</p>
<p>Qt中常用的用于socket通信的套接字类:</p>
<ul>
<li><p>QTcpServer 用于TCP通信, 作为服务器端套接字使用</p>
</li>
<li><p>QTcpSocket 用于TCP通信，作为客户端套接字使用。</p>
</li>
<li><p>QUdpSocket 用于UDP通信，服务器，客户端均使用此套接字。</p>
</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>在Qt中实现TCP服务器端通信的流程:</p>
<ol>
<li><p>创建套接字</p>
</li>
<li><p>将套接字设置为监听模式</p>
</li>
<li><p>等待并接受客户端请求</p>
<p> 可以通过QTcpServer提供的void <strong>newConnection()**</strong>信号*<em>来检测是否有连接请求，如果有可以在对应的槽函数中调用nextPendingConnection函数获取到客户端的Socket信息（返回值为QTcpSocket</em>类型指针），通过此套接字与客户端之间进行通信。</p>
</li>
<li><p>接收或者向客户端发送数据</p>
<p>接收数据：使用read（）或者readAll（）函数</p>
<p>发送数据：使用write（）函数</p>
</li>
</ol>
<p>在Qt中实现TCP/IP客户端通信的流程:</p>
<ol>
<li><p>创建套接字</p>
</li>
<li><p>连接服务器</p>
<p> 可以使用QTcpSocket类的<strong>connectToHost（）</strong>函数来连接服务器。</p>
</li>
<li><p>向服务器发送或者接受数据</p>
</li>
</ol>
<p>下面例子为简单的TCP/IP通信的实现例子:</p>
<h4 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//---------- tcpserver.h ------------</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TCPServer</span><span class="hljs-params">(QWidget *parent = <span class="hljs-number">0</span>)</span></span>;<br>    ~TCPServer();<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slotNewConnection</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slotReadyRead</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Ui::TCPServer *ui;<br>    <span class="hljs-comment">// 负责监听的套接字</span><br>    QTcpServer* m_server;<br>    <span class="hljs-comment">// 负责通信的套接字</span><br>    QTcpSocket* m_client;<br>&#125;;<br><br><span class="hljs-comment">//---------- tcpserver.cpp ------------</span><br>TCPServer::TCPServer(QWidget *parent) :<br>    QMainWindow(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::TCPServer),<br>    m_server(<span class="hljs-literal">NULL</span>),<br>    m_client(<span class="hljs-literal">NULL</span>)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">//创建套接字对象</span><br>    m_server = <span class="hljs-keyword">new</span> QTcpServer(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//将套接字设置为监听模式</span><br>    m_server-&gt;listen(QHostAddress::Any, <span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">//通过信号接收客户端请求</span><br>    connect(m_server, &amp;QTcpServer::newConnection, <br><span class="hljs-keyword">this</span>, &amp;TCPServer::slotNewConnection);<br>&#125;<br><br>TCPServer::~TCPServer()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPServer::slotNewConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(m_client == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-comment">//处理客户端的连接请求</span><br>        m_client = m_server-&gt;nextPendingConnection();<br>        <span class="hljs-comment">//发送数据</span><br>        m_client-&gt;write(<span class="hljs-string">&quot;服务器连接成功!!!&quot;</span>);<br>        <span class="hljs-comment">//连接信号, 接收客户端数据</span><br>        connect(m_client, &amp;QTcpSocket::readyRead, <br><span class="hljs-keyword">this</span>, &amp;TCPServer::slotReadyRead);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPServer::slotReadyRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//接收数据</span><br>    QByteArray <span class="hljs-built_in">array</span> = m_client-&gt;readAll();<br>    QMessageBox::information(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Client Message&quot;</span>, <span class="hljs-built_in">array</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//------------- tcpclient.h ------------</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPClient</span> :</span> <span class="hljs-keyword">public</span> QMainWindow<br>&#123;<br>    Q_OBJECT<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TCPClient</span><span class="hljs-params">(QWidget *parent = <span class="hljs-number">0</span>)</span></span>;<br>    ~TCPClient();<br><br><span class="hljs-keyword">public</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slotReadyRead</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slotSendMsg</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    Ui::TCPClient *ui;<br>    QTcpSocket* m_client;<br>&#125;;<br><br><span class="hljs-comment">//------------- tcpclient.cpp --------------</span><br>TCPClient::TCPClient(QWidget *parent) :<br>    QMainWindow(parent),<br>    ui(<span class="hljs-keyword">new</span> Ui::TCPClient)<br>&#123;<br>    ui-&gt;setupUi(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//创建套接字</span><br>    m_client = <span class="hljs-keyword">new</span> QTcpSocket(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">//连接服务器</span><br>    m_client-&gt;connectToHost(QHostAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">//通过信号接收服务器数据</span><br>    connect(m_client, &amp;QTcpSocket::readyRead, <br><span class="hljs-keyword">this</span>, &amp;TCPClient::slotReadyRead);<br>    <span class="hljs-comment">//发送按钮</span><br>    connect(ui-&gt;btnSend, &amp;QPushButton::clicked, <br><span class="hljs-keyword">this</span>, &amp;TCPClient::slotSendMsg);<br>&#125;<br><br>TCPClient::~TCPClient()<br>&#123;<br>    <span class="hljs-keyword">delete</span> ui;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPClient::slotReadyRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	 <span class="hljs-comment">//接收数据</span><br>    QByteArray <span class="hljs-built_in">array</span> = m_client-&gt;readAll();<br>    QMessageBox::information(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Server Message&quot;</span>, <span class="hljs-built_in">array</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TCPClient::slotSendMsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    QString text = ui-&gt;textEdit-&gt;toPlainText();<br>	 <span class="hljs-comment">//发送数据</span><br>    m_client-&gt;write(text.toUtf8());<br>    ui-&gt;textEdit-&gt;clear();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p><strong>在UDP方式下，客户端并不与服务器建立连接，它只负责调用发送函数向服务器发送数据</strong>。类似的<strong>服务器也不从客户端接收连接，只负责调用接收函数，等待来自客户端的数据的到达</strong>。</p>
<p>在UDP通信中，服务器端和客户端的概念已经显得有些淡化，两部分做的工作都大致相同：</p>
<ol>
<li><p> 创建套接字</p>
</li>
<li><p>绑定套接字</p>
<p> 在UDP中如果需要<strong>接收数据</strong>则<strong>需要对套接字进行绑定</strong>，只发送数据则不需要对套接字进行绑定。</p>
<p> 通过调用bind（）函数将套接字绑定到指定端口上。</p>
</li>
<li><p>接收或者发送数据</p>
</li>
</ol>
<ul>
<li>接收数据：使用readDatagram()接收数据,函数声明如下:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">qint64 <span class="hljs-title">readDatagram</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * data, qint64 maxSize, QHostAddress * address = <span class="hljs-number">0</span>, quint16 * port = <span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>​    参数:</p>
<p> data: 接收数据的缓存地址</p>
<p> maxSize: 缓存接收的最大字节数</p>
<p> address: 数据发送方的地址（一般使用提供的默认值）</p>
<p> port: 数据发送方的端口号（一般使用提供的默认值）</p>
<p>使用<strong>pendingDatagramSize()可以获取到将要接收的数据的大小</strong>，根据该函数返回值来准备对应大小的内存空间存放将要接收的数据。</p>
<ul>
<li>发送数据: 使用writeDatagram()函数发送数据，函数声明如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">qint64 <span class="hljs-title">writeDatagram</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QByteArray &amp; datagram, <span class="hljs-keyword">const</span> QHostAddress &amp; host, quint16 port)</span></span><br></code></pre></td></tr></table></figure>

<p>​    参数：</p>
<p> datagram：要发送的字符串</p>
<p> host：数据接收方的地址</p>
<p> port：数据接收方的端口号</p>
<h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>在使用QUdpSocket类的writeDatagram()函数发送数据的时候，其中第二个参数host应该指定为广播地址：QHostAddress：：Broadcast此设置相当于QHostAddress(“255.255.255.255”)</p>
<p>使用UDP广播的的特点：</p>
<ul>
<li><p>使用UDP进行广播，局域网内的其他的UDP用户全部可以收到广播的消息</p>
</li>
<li><p>UDP广播只能在局域网范围内使用</p>
</li>
</ul>
<h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><p>在使用QUdpSocket类的writeDatagram()函数发送数据的时候，其中第二个参数host应该指定为组播地址，关于组播地址的分类：</p>
<ul>
<li><p>224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；</p>
</li>
<li><p>224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet；</p>
</li>
<li><p>224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效；</p>
</li>
<li><p>239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效。</p>
</li>
</ul>
<p>注册加入到组播地址需要使用QUdpSocket类的成员函数：</p>
<p>bool  joinMulticastGroup(const QHostAddress &amp; groupAddress)</p>
<h3 id="TCP-和-UDP的区别"><a href="#TCP-和-UDP的区别" class="headerlink" title="TCP 和 UDP的区别"></a>TCP 和 UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th><strong>TCP</strong></th>
<th align="center"><strong>UDP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td>传输方式</td>
<td>基于流</td>
<td align="center">基于数据报</td>
</tr>
<tr>
<td>传输可靠性</td>
<td>可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td>传输效率</td>
<td>效率低</td>
<td align="center">效率高</td>
</tr>
<tr>
<td>能否广播</td>
<td>不能</td>
<td align="center">能</td>
</tr>
</tbody></table>
<h2 id="九、多线程的使用"><a href="#九、多线程的使用" class="headerlink" title="九、多线程的使用"></a>九、多线程的使用</h2><p><strong>在次线程中处理的业务放在独立的模块（类）中，由主线程创建完该对象后，将其移交给指定的线程，且可以将多个类似的对象移交给同一个线程。</strong></p>
<p>例子中，信号由主线程的QTimer对象发出，之后Qt会将关联的事件放到worker所属线程的事件队列。由于队列连接的作用，在不同线程间连接信号和槽是很安全的。</p>
<p>示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> :</span> <span class="hljs-keyword">public</span> QObject<br>&#123;<br>    Q_OBJECT<br><span class="hljs-keyword">private</span> slots:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onTimeout</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        qDebug()&lt;&lt;<span class="hljs-string">&quot;Worker::onTimeout get called from?: &quot;</span><br>&lt;&lt;QThread::currentThreadId();<br>    &#125;<br>&#125;;<br>    <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    qDebug()&lt;&lt;<span class="hljs-string">&quot;From main thread: &quot;</span>&lt;&lt;QThread::currentThreadId();<br>  <br>    QThread t;<br>    QTimer timer;<br>    Worker worker;<br>  <br>    QObject::connect(&amp;timer, SIGNAL(timeout()), <br>&amp;worker, SLOT(onTimeout()));<br>		 <span class="hljs-comment">// 启动定时器</span><br>    timer.start(<span class="hljs-number">1000</span>);<br>  	 <span class="hljs-comment">// 将类对象移交个线程</span><br>    worker.moveToThread(&amp;t);<br>    <span class="hljs-comment">// 启动线程</span><br>    t.start();<br>  <br>    <span class="hljs-keyword">return</span> a.exec();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关于Qobject类的connect函数最后一个参数，连接类型：</p>
<ul>
<li><p>自动连接(AutoConnection)，默认的连接方式。</p>
<p>如果信号与槽，也就是发送者与接受者在同一线程，等同于直接连接；</p>
<p>如果发送者与接受者处在不同线程，等同于队列连接。</p>
</li>
<li><p>直接连接(DirectConnection)</p>
</li>
</ul>
<p>当信号发射时，槽函数立即直接调用。<strong>无论槽函数所属对象在哪个线程，槽函数总在发送者所在线程执行。</strong></p>
<ul>
<li>队列连接(QueuedConnection)</li>
</ul>
<p>当控制权回到接受者所在线程的事件循环时，槽函数被调用。<strong>槽函数在接受者所在线程执行。</strong></p>
<p><strong>总结：</strong></p>
<p>* <strong>队列连接：槽函数在接受者所在线程执行</strong>。</p>
<p>* <strong>直接连接：槽函数在发送者所在线程执行</strong>。</p>
<p>*<strong>自动连接：二者不在同一线程时，等同于队列连接</strong></p>
<p><strong>多线程使用过程中注意事项：</strong></p>
<ul>
<li><p><strong>线程不能操作UI对象（从Qwidget直接或间接派生的窗口对象）</strong></p>
</li>
<li><p><strong>需要移动到子线程中处理的模块类，创建的对象的时候不能指定父对象。</strong></p>
</li>
</ul>
<h2 id="十、Qt数据库操作"><a href="#十、Qt数据库操作" class="headerlink" title="十、Qt数据库操作"></a>十、Qt数据库操作</h2><h3 id="一、操作数据库"><a href="#一、操作数据库" class="headerlink" title="一、操作数据库"></a>一、操作数据库</h3><p><strong>Qt 提供了 QtSql 模块来提供平台独立的基于 SQL 的数据库操作。</strong></p>
<p><strong>Qt 使用QSqlDatabase表示一个数据库连接。</strong></p>
<p>可以通过：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//打印Qt支持的数据库驱动</span><br>qDebug() &lt;&lt; QSqlDatabase::drivers();<br></code></pre></td></tr></table></figure>

<p>找到系统中所有可用的数据库驱动的名字列表。</p>
<p>封装一个连接数据库的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QString &amp;dbName)</span></span><br><span class="hljs-function"></span>&#123;<br>    QSqlDatabase db = QSqlDatabase::addDatabase(<span class="hljs-string">&quot;QSQLITE&quot;</span>);<br><span class="hljs-comment">//    db.setHostName(&quot;host&quot;);</span><br><span class="hljs-comment">//    db.setDatabaseName(&quot;dbname&quot;);</span><br><span class="hljs-comment">//    db.setUserName(&quot;username&quot;);</span><br><span class="hljs-comment">//    db.setPassword(&quot;password&quot;);</span><br>    db.setDatabaseName(dbName);<br>    <span class="hljs-keyword">if</span> (!db.open()) &#123;<br>        QMessageBox::critical(<span class="hljs-number">0</span>, QObject::tr(<span class="hljs-string">&quot;Database Error&quot;</span>),<br>                              db.lastError().text());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建数据库表student后，插入数据，然后将其独取出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (connect(<span class="hljs-string">&quot;demo.db&quot;</span>)) <br>&#123;<br>    QSqlQuery query;<br>    query.prepare(<span class="hljs-string">&quot;INSERT INTO student (name, age) VALUES (?, ?)&quot;</span>);<br>    QVariantList names;<br>    names &lt;&lt; <span class="hljs-string">&quot;Tom&quot;</span> &lt;&lt; <span class="hljs-string">&quot;Jack&quot;</span> &lt;&lt; <span class="hljs-string">&quot;Jane&quot;</span> &lt;&lt; <span class="hljs-string">&quot;Jerry&quot;</span>;<br>    query.addBindValue(names);<br>    QVariantList ages;<br>    ages &lt;&lt; <span class="hljs-number">20</span> &lt;&lt; <span class="hljs-number">23</span> &lt;&lt; <span class="hljs-number">22</span> &lt;&lt; <span class="hljs-number">25</span>;<br>    query.addBindValue(ages);<br>    <span class="hljs-keyword">if</span> (!query.execBatch()) &#123;<br>        QMessageBox::critical(<span class="hljs-number">0</span>, QObject::tr(<span class="hljs-string">&quot;Database Error&quot;</span>),<br>                              query.lastError().text());<br>    &#125;<br> <br>    query.exec(<span class="hljs-string">&quot;SELECT name, age FROM student&quot;</span>);<br>    <span class="hljs-keyword">while</span> (query.next()) &#123;<br>        QString name = query.value(<span class="hljs-number">0</span>).toString();<br>        <span class="hljs-keyword">int</span> age = query.value(<span class="hljs-number">1</span>).toInt();<br>        qDebug() &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; age;<br>    &#125;<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入多条数据，此时可以使用QSqlQuery::exec()函数一条一条插入数据，但是这里我们选择了另外一种方法：批量执行。首先，我们使用<strong>QSqlQuery::prepare()函数对这条 SQL 语句进行预处理，问号 ? 相当于占位符，预示着以后我们可以使用实际数据替换这些位置。</strong></p>
<p>在上面的代码中，我们使用一个字符串列表 names 替换掉第一个问号的位置，一个整型列表 ages 替换掉第二个问号的位置，利用<strong>QSqlQuery::addBindValue()我们将实际数据绑定到这个预处理的 SQL 语句上</strong>。需要注意的是，names 和 ages 这两个列表里面的数据需要一一对应。然后我们调用<strong>QSqlQuery::execBatch()批量执行 SQL，之后结束该对象。</strong>这样，插入操作便完成了。</p>
<h3 id="二、使用模型操作数据库"><a href="#二、使用模型操作数据库" class="headerlink" title="二、使用模型操作数据库"></a>二、使用模型操作数据库</h3><p><strong>基于QSqlTableModel 的模型处理更为高级，如果对 SQL 语句不熟悉，并且不需要很多复杂的查询，这种QSqlTableModel模型基本可以满足一般的需求。</strong></p>
<h4 id="1、查询操作"><a href="#1、查询操作" class="headerlink" title="1、查询操作"></a>1、查询操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (connect(<span class="hljs-string">&quot;demo.db&quot;</span>)) <br>&#123;<br>    QSqlTableModel model;<br>    model.setTable(<span class="hljs-string">&quot;student&quot;</span>);<br>    model.setFilter(<span class="hljs-string">&quot;age &gt; 20 and age &lt; 25&quot;</span>);<br>    <span class="hljs-keyword">if</span> (model.select()) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; model.rowCount(); ++i) &#123;<br>            QSqlRecord record = model.record(i);<br>            QString name = record.value(<span class="hljs-string">&quot;name&quot;</span>).toString();<br>            <span class="hljs-keyword">int</span> age = record.value(<span class="hljs-string">&quot;age&quot;</span>).toInt();<br>            qDebug() &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; age;<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>setTable()函数设置所需要操作的表格；</p>
</li>
<li><p>setFilter()函数则是添加过滤器，也就是 WHERE 语句所需要的部分。</p>
<p>  例如上面代码中的操作实际相当于 SQL 语句:</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">SELECT * FROM student WHERE age &gt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> age &lt; <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意：我们使用QSqlTableModel只能进行 SELECT * 的查询，不能只查询其中某些列的数据。</strong></p>
<h4 id="2、插入操作"><a href="#2、插入操作" class="headerlink" title="2、插入操作"></a>2、插入操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">QSqlTableModel model;<br>model.setTable(<span class="hljs-string">&quot;student&quot;</span>);<br><span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>model.insertRows(row, <span class="hljs-number">1</span>);<br>model.setData(model.index(row, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;Cheng&quot;</span>);<br>model.setData(model.index(row, <span class="hljs-number">2</span>), <span class="hljs-number">24</span>);<br>model.submitAll();<br></code></pre></td></tr></table></figure>

<p>model.insertRows(row, 1);说明我们想在索引 0 的位置插入 1 行新的数据。使用<strong>setData()函数则开始准备实际需要插入的数据</strong>。最后，调用<strong>submitAll()函数提交所有修改</strong>。</p>
<p>例如上面代码中的操作实际相当于 SQL 语句:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">INSERT INTO student (name, age) VALUES (&#x27;Cheng&#x27;, 24)<br></code></pre></td></tr></table></figure>

<h4 id="3、更新操作"><a href="#3、更新操作" class="headerlink" title="3、更新操作"></a>3、更新操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">QSqlTableModel model;<br>model.setTable(<span class="hljs-string">&quot;student&quot;</span>);<br>model.setFilter(<span class="hljs-string">&quot;age = 25&quot;</span>);<br><span class="hljs-keyword">if</span> (model.select()) &#123;<br>    <span class="hljs-keyword">if</span> (model.rowCount() == <span class="hljs-number">1</span>) &#123;<br>        QSqlRecord record = model.record(<span class="hljs-number">0</span>);<br>        record.setValue(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">26</span>);<br>        model.setRecord(<span class="hljs-number">0</span>, record);<br>        model.submitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>找到 age = 25 的记录，然后将 age 重新设置为 26，存入相同的位置（在这里都是索引 0 的位置），提交之后完成一次更新</p>
<p>例如上面代码中的操作实际相当于 SQL 语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">UPDATE student SET age = <span class="hljs-number">26</span> WHERE age = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure>

<h4 id="4、删除操作"><a href="#4、删除操作" class="headerlink" title="4、删除操作"></a>4、删除操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">QSqlTableModel model;<br>model.setTable(<span class="hljs-string">&quot;student&quot;</span>);<br>model.setFilter(<span class="hljs-string">&quot;age = 25&quot;</span>);<br><span class="hljs-keyword">if</span> (model.select()) &#123;<br>    <span class="hljs-keyword">if</span> (model.rowCount() == <span class="hljs-number">1</span>) &#123;<br>        model.removeRows(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        model.submitAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>removeRows()函数可以一次删除多行。</p>
<p>例如上面代码中的操作实际相当于 SQL 语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">DELETE FROM student WHERE age = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure>



<p>如果你觉得文章还不错，记得”<strong>点赞关注</strong>“</p>
<p>关注我的微信公众号【 <strong>加班猿</strong> 】可以获取更多内容</p>
<p><img src="https://img-blog.csdnimg.cn/20201028200900702.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2020/11/01/Qt%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8/">← Prev Qt实现一个简单的计算器</a><span style="color: #fe2"> | </span><a href="/2020/10/20/LCD1602%E5%8D%95%E7%89%87%E6%9C%BA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F(STC51STM32)%E8%AF%A6%E8%A7%A3/">LCD1602单片机(STC51/STM32)驱动程序详解 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'Nq5lj4VJyzKxDJIKCQ8wQAWs-gzGzoHsz'
 , appKey: 'RSAaB7CGtQpU2kjI3iFgD7Rz'
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/CodingEmbedded"> Dr.hackett</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">9</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">5</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">4</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">一、常用控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%92%AE%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">按钮类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#item"><span class="toc-number">1.2.</span> <span class="toc-text">item</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">编辑类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">显示类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">2.</span> <span class="toc-text">二、信号与槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">2.1.</span> <span class="toc-text">信号和槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD"><span class="toc-number">2.2.</span> <span class="toc-text">自定义信号槽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">自定义信号槽需要注意的事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Qt%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">三、Qt窗口系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB"><span class="toc-number">3.1.</span> <span class="toc-text">1、坐标体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81QWidget"><span class="toc-number">3.2.</span> <span class="toc-text">2、QWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81QMainWindow"><span class="toc-number">3.3.</span> <span class="toc-text">3、QMainWindow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86QDialog"><span class="toc-number">3.4.</span> <span class="toc-text">4、对话框QDialog</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">四、布局管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.1.</span> <span class="toc-text">绝对定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.2.</span> <span class="toc-text">布局定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">自定义控件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">五、消息机制和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#event"><span class="toc-number">5.2.</span> <span class="toc-text">event()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">事件过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%BB%98%E5%9B%BE%E5%92%8C%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87"><span class="toc-number">6.</span> <span class="toc-text">六、绘图和绘图设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QPainter"><span class="toc-number">6.1.</span> <span class="toc-text">QPainter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87"><span class="toc-number">6.2.</span> <span class="toc-text">绘图设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A7%84%E5%88%99%E7%AA%97%E5%8F%A3"><span class="toc-number">6.3.</span> <span class="toc-text">不规则窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">七、文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Socket%E9%80%9A%E4%BF%A1"><span class="toc-number">8.</span> <span class="toc-text">八、Socket通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-number">8.1.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">8.1.1.</span> <span class="toc-text">TCP服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">8.1.2.</span> <span class="toc-text">TCP客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-number">8.2.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">8.2.1.</span> <span class="toc-text">广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%92%AD"><span class="toc-number">8.2.2.</span> <span class="toc-text">组播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">TCP 和 UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">九、多线程的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Qt%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">10.</span> <span class="toc-text">十、Qt数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">10.1.</span> <span class="toc-text">一、操作数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">10.2.</span> <span class="toc-text">二、使用模型操作数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.1.</span> <span class="toc-text">1、查询操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.2.</span> <span class="toc-text">2、插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.3.</span> <span class="toc-text">3、更新操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.4.</span> <span class="toc-text">4、删除操作</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>