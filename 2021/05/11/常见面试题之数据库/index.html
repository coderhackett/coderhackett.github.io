<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>常见面试题之数据库 | 加班猿</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.8.2/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.2.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2021-05-10T16:00:00.000Z" id="date"> 2021-05-11</time></span><br><span>updated:<time datetime="2021-07-02T11:44:05.118Z" id="updated"> 2021-07-02</time></span></div><h1>常见面试题之数据库</h1><hr></div><div id="post-content"><p><img src="https://img-blog.csdnimg.cn/20201029203102512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div align = 'right'>作者：hackett</div>

<div align = 'right'>微信公众号：加班猿</div>

<h2 id="1、数据库基础"><a href="#1、数据库基础" class="headerlink" title="1、数据库基础"></a>1、数据库基础</h2><h3 id="1-请你说一下数据库事务以及四个特性"><a href="#1-请你说一下数据库事务以及四个特性" class="headerlink" title="1 请你说一下数据库事务以及四个特性"></a>1 请你说一下数据库事务以及四个特性</h3><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。</p>
<p>事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。</p>
<p>\1. 原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<p>\2. 一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>\3. 隔离性（Isolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</p>
<p>这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p>
<p>不同的隔离级别：</p>
<p>Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。</p>
<p>Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。</p>
<p>Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。</p>
<p>Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。</p>
<p>\4. 持久性（Durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h3 id="2-请你介绍一下数据库的ACID特性"><a href="#2-请你介绍一下数据库的ACID特性" class="headerlink" title="2 请你介绍一下数据库的ACID特性"></a>2 请你介绍一下数据库的ACID特性</h3><p>1)原子性：事务被视为不可分割的最小单元，事物的所有操作要不成功，要不失败回滚，而回滚可以通过日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作。</p>
<p>2)一致性：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<p>3)隔离性：一个事务所做的修改在最终提交以前，对其他事务是可不见的。</p>
<p>4)持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。</p>
<h3 id="3-请你说一说数据库事务隔离"><a href="#3-请你说一说数据库事务隔离" class="headerlink" title="3 请你说一说数据库事务隔离"></a>3 请你说一说数据库事务隔离</h3><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<h3 id="4-请你说一说inner-join和left-join"><a href="#4-请你说一说inner-join和left-join" class="headerlink" title="4 请你说一说inner join和left join"></a>4 请你说一说inner join和left join</h3><p>left join(左联接) <strong>返回包括左表中的所有记录和右表中联结字段相等的记录</strong></p>
<p>right join(右联接) <strong>返回包括右表中的所有记录和左表中联结字段相等的记录</strong></p>
<h3 id="5-请你说说索引是什么，多加索引一定会好吗"><a href="#5-请你说说索引是什么，多加索引一定会好吗" class="headerlink" title="5 请你说说索引是什么，多加索引一定会好吗"></a>5 请你说说索引是什么，多加索引一定会好吗</h3><p>1、索引</p>
<p>数据库索引是为了<strong>增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构</strong>。</p>
<p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p>
<p>优点：</p>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
<p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
<p>缺点：</p>
<p>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p>
<p>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p>
<h2 id="2、MySQL"><a href="#2、MySQL" class="headerlink" title="2、MySQL"></a>2、MySQL</h2><h3 id="1-请你说一说mysql的四种隔离状态"><a href="#1-请你说一说mysql的四种隔离状态" class="headerlink" title="1 请你说一说mysql的四种隔离状态"></a>1 请你说一说mysql的四种隔离状态</h3><p>Mysql主要包含四种隔离状态：</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="2-请你介绍一下mysql的MVCC机制"><a href="#2-请你介绍一下mysql的MVCC机制" class="headerlink" title="2 请你介绍一下mysql的MVCC机制"></a>2 请你介绍一下mysql的MVCC机制</h3><p>MVCC是一种多版本并发控制机制，是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p>
<h3 id="3-请问SQL优化方法有哪些"><a href="#3-请问SQL优化方法有哪些" class="headerlink" title="3 请问SQL优化方法有哪些"></a>3 请问SQL优化方法有哪些</h3><p>通过建立索引对查询进行优化</p>
<p>对查询进行优化，应尽量避免全表扫描</p>
<h3 id="4-请你说一下MySQL引擎和区别"><a href="#4-请你说一下MySQL引擎和区别" class="headerlink" title="4 请你说一下MySQL引擎和区别"></a>4 请你说一下MySQL引擎和区别</h3><p>1、MySQL引擎</p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p>
<p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。</p>
<p>但是最常用的是InnoDB和Mylsam。</p>
<p>2、InnoDB</p>
<p>InnoDB是一个事务型的存储引擎，有行级锁定和外键约束。</p>
<p>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这类型的文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p>
<p>适用场景：</p>
<p>经常更新的表，适合处理多重并发的更新请求。</p>
<p>支持事务。</p>
<p>可以从灾难中恢复（通过bin-log日志等）。</p>
<p>外键约束。只有他支持外键。</p>
<p>支持自动增加列属性auto_increment。</p>
<p>索引结构：</p>
<p>InnoDB也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p>
<p>3、Mylsam</p>
<p>MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT或UPDATE数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p>
<p>适用场景：</p>
<p>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</p>
<p>不支持外键的表设计。</p>
<p>查询速度很快，如果数据库insert和update的操作比较多的话比较适用。</p>
<p>整天对表进行加锁的场景。</p>
<p>MyISAM极度强调快速读取操作。</p>
<p>MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</p>
<p>缺点：就是不能在表损坏后主动恢复数据。</p>
<p>索引结构：</p>
<p>MyISAM索引结构：MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>
<p>3、InnoDB和Mylsam的区别：</p>
<p>1）事务：MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。</p>
<p>2）性能：MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。</p>
<p>3）行数保存：InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。</p>
<p>4）索引存储：对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持。</p>
<p>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大不小。</p>
<p>InnoDB存储引擎被完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB存储它的表＆索引在一个表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与MyISAM表不同，比如在MyISAM表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</p>
<p>5）服务器数据备份：InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。</p>
<p>MyISAM应对错误编码导致的数据恢复速度快。MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</p>
<p>InnoDB是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p>
<p>6）锁的支持：MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p>
<h2 id="3、Redis"><a href="#3、Redis" class="headerlink" title="3、Redis"></a>3、Redis</h2><h3 id="1-请你回答一下mongodb和redis的区别"><a href="#1-请你回答一下mongodb和redis的区别" class="headerlink" title="1 请你回答一下mongodb和redis的区别"></a>1 请你回答一下mongodb和redis的区别</h3><p>内存管理机制上：<strong>Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据</strong>。<strong>MongoDB 数据存在内存，由 linux系统 mmap 实现，当内存不够时，只将热点数据放入内存，其他数据存在磁盘</strong>。</p>
<p>支持的数据结构上：<strong>Redis 支持的数据结构丰富，包括hash、set、list</strong>等。</p>
<p>MongoDB 数据结构比较单一，但是<strong>支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富</strong></p>
<h3 id="2-请你来说一说Redis的定时机制怎么实现的"><a href="#2-请你来说一说Redis的定时机制怎么实现的" class="headerlink" title="2 请你来说一说Redis的定时机制怎么实现的"></a>2 请你来说一说Redis的定时机制怎么实现的</h3><p>Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。<strong>Redis的定时机制就是借助时间事件实现的。</strong></p>
<p>一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件</p>
<h3 id="3-请你来说一说Redis是单线程的，但是为什么这么高效呢"><a href="#3-请你来说一说Redis是单线程的，但是为什么这么高效呢" class="headerlink" title="3 请你来说一说Redis是单线程的，但是为什么这么高效呢?"></a>3 请你来说一说Redis是单线程的，但是为什么这么高效呢?</h3><p>虽然Redis文件事件处理器以单线程方式运行，但是<strong>通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型</strong>，又可以很好地与Redis服务器中其他同样以单线程运行的模块进行对接，这保持了Redis内部单线程设计的简单性。</p>
<h3 id="4-请问Redis的数据类型有哪些，底层怎么实现"><a href="#4-请问Redis的数据类型有哪些，底层怎么实现" class="headerlink" title="4 请问Redis的数据类型有哪些，底层怎么实现?"></a>4 请问Redis的数据类型有哪些，底层怎么实现?</h3><p>1）字符串string（整数值、embstr编码的简单动态字符串、简单动态字符串（SDS)）   </p>
<p>2）列表list（压缩列表、双端链表）</p>
<p>3）哈希hash（压缩列表、字典）</p>
<p>4）集合set（整数集合、字典）</p>
<p>5）有序集合zset（压缩列表、跳跃表、字典）</p>
<h3 id="5-请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的"><a href="#5-请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的" class="headerlink" title="5 请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?"></a>5 请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</h3><p>因为redis是单线程，当K很多时，如果<strong>一次性将键值对全部rehash，庞大的计算量会影响服务器性能，甚至可能会导致服务器在一段时间内停止服务</strong>。不可能一步完成整个rehash操作，所以redis是分多次、渐进式的rehash。渐进性哈希分为两种：</p>
<p>1）<strong>操作redis时，额外做一步rehash</strong></p>
<p>对redis做读取、插入、删除等操作时，会把位于table[dict-&gt;rehashidx]位置的链表移动到新的dictht中，然后把rehashidx做加一操作，移动到后面一个槽位。</p>
<p>2）<strong>后台定时任务调用rehash</strong></p>
<p>后台定时任务rehash调用链，同时可以通过server.hz控制rehash调用频率</p>
<h3 id="6-redis-和-memcached-的区别？"><a href="#6-redis-和-memcached-的区别？" class="headerlink" title="6 redis 和 memcached 的区别？"></a>6 redis 和 memcached 的区别？</h3><p><strong>存储方式不同</strong>：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</p>
<p><strong>数据支持类型</strong>：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</p>
<p><strong>使用底层模型不同</strong>：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。</p>
<p>如果你觉得文章还不错，记得”<strong>点赞关注</strong>“</p>
<p>关注我的微信公众号【 <strong>加班猿</strong> 】可以获取更多内容<br><img src="https://img-blog.csdnimg.cn/20201017112132917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/05/11/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">← Prev 常见面试题之操作系统</a><span style="color: #fe2"> | </span><a href="/2021/03/13/STL%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/">STL核心编程 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'Nq5lj4VJyzKxDJIKCQ8wQAWs-gzGzoHsz'
 , appKey: 'RSAaB7CGtQpU2kjI3iFgD7Rz'
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/coderhackett"> Dr.hackett</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">22</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">11</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">12</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1、数据库基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">1 请你说一下数据库事务以及四个特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">2 请你介绍一下数据库的ACID特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB"><span class="toc-number">1.3.</span> <span class="toc-text">3 请你说一说数据库事务隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4inner-join%E5%92%8Cleft-join"><span class="toc-number">1.4.</span> <span class="toc-text">4 请你说一说inner join和left join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A4%9A%E5%8A%A0%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E4%BC%9A%E5%A5%BD%E5%90%97"><span class="toc-number">1.5.</span> <span class="toc-text">5 请你说说索引是什么，多加索引一定会好吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81MySQL"><span class="toc-number">2.</span> <span class="toc-text">2、MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">1 请你说一说mysql的四种隔离状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bmysql%E7%9A%84MVCC%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2 请你介绍一下mysql的MVCC机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B7%E9%97%AESQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.3.</span> <span class="toc-text">3 请问SQL优化方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E5%BC%95%E6%93%8E%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4 请你说一下MySQL引擎和区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Redis"><span class="toc-number">3.</span> <span class="toc-text">3、Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B7%E4%BD%A0%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bmongodb%E5%92%8Credis%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">1 请你回答一下mongodb和redis的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4Redis%E7%9A%84%E5%AE%9A%E6%97%B6%E6%9C%BA%E5%88%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.2.</span> <span class="toc-text">2 请你来说一说Redis的定时机制怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B7%E4%BD%A0%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E9%AB%98%E6%95%88%E5%91%A2"><span class="toc-number">3.3.</span> <span class="toc-text">3 请你来说一说Redis是单线程的，但是为什么这么高效呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%B7%E9%97%AERedis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">4 请问Redis的数据类型有哪些，底层怎么实现?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%B7%E9%97%AERedis%E7%9A%84rehash%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B8%90%E8%BF%9Brehash%EF%BC%8C%E6%B8%90%E8%BF%9Brehash%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.5.</span> <span class="toc-text">5 请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">6 redis 和 memcached 的区别？</span></a></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>