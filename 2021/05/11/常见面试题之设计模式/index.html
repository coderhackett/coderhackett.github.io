<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>常见面试题之设计模式 | 加班猿</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/8.8.2/mermaid.min.js"></script><script>mermaid.initialize({
  startOnLoad: true
  , theme: 'dark'
});</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.2.0"></head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2021-05-10T16:00:00.000Z" id="date"> 2021-05-11</time></span><br><span>updated:<time datetime="2021-07-02T11:44:17.313Z" id="updated"> 2021-07-02</time></span></div><h1>常见面试题之设计模式</h1><hr></div><div id="post-content"><p><img src="https://img-blog.csdnimg.cn/20201029203102512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div align = 'right'>作者：hackett</div>

<div align = 'right'>微信公众号：加班猿</div>

<h3 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1 说一下你熟悉的设计模式？"></a>1 说一下你熟悉的设计模式？</h3><p><strong>单例模式</strong>：保证被创建一次，节省系统开销。</p>
<p><strong>工厂模式</strong>（简单工厂、抽象工厂）：解耦代码。</p>
<p><strong>观察者模式</strong>：<strong>定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新</strong>。</p>
<p><strong>外观模式</strong>：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</p>
<p><strong>模版方法模式</strong>：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</p>
<p><strong>状态模式</strong>：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<h3 id="2-C-单例模式总结"><a href="#2-C-单例模式总结" class="headerlink" title="2 C++单例模式总结"></a>2 C++单例模式总结</h3><h4 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h4><p>在拥有<strong>共享数据</strong>的<strong>多条线程并行执行</strong>的程序中，线程安全的代码会通过<strong>同步机制</strong>保证<strong>各个线程</strong>都可以正常且正确的执行，不会出现数据污染等意外情况。</p>
<hr>
<h4 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h4><ol>
<li>给<strong>共享的资源</strong>加把<strong>锁</strong>，保证每个资源变量每时每刻至多被一个线程占用。</li>
<li>让线程也拥有资源，不用去共享进程中的资源。如： 使用<strong>threadlocal</strong>可以为每个线程的维护一个<strong>私有的</strong>本地变量。</li>
</ol>
<hr>
<h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的<strong>唯一性</strong>。</p>
<h4 id="单例模式分类"><a href="#单例模式分类" class="headerlink" title="单例模式分类"></a>单例模式分类</h4><p>单例模式可以分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，两者之间的区别在于<strong>创建实例的时间不同</strong>：</p>
<ul>
<li><strong>懒汉式</strong>：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。<strong>（这种方式要考虑线程安全）</strong></li>
<li><strong>饿汉式</strong>：指系统一运行，就初始化创建实例，当需要时，直接调用即可。<strong>（本身就线程安全，没有多线程的问题）</strong></li>
</ul>
<h4 id="单例类特点"><a href="#单例类特点" class="headerlink" title="单例类特点"></a>单例类特点</h4><ul>
<li>构造函数和析构函数为<strong>private</strong>类型，目的<strong>禁止</strong>外部构造和析构</li>
<li>拷贝构造和赋值构造函数为<strong>private</strong>类型，目的是<strong>禁止</strong>外部拷贝和赋值，确保实例的唯一性</li>
<li>类里有个获取实例的<strong>静态函数</strong>，可以全局访问</li>
</ul>
<h4 id="普通懒汉式单例运行结果："><a href="#普通懒汉式单例运行结果：" class="headerlink" title="普通懒汉式单例运行结果："></a>普通懒汉式单例运行结果：</h4><p>从运行结果可知，单例构造函数创建了两个，内存地址分别为<code>0x7f3c980008c0</code>和<code>0x7f3c900008c0</code>，所以普通懒汉式单例只适合单进程不适合多线程，因为是线程不安全的</p>
<h4 id="加锁的懒汉式单例的运行结果："><a href="#加锁的懒汉式单例的运行结果：" class="headerlink" title="加锁的懒汉式单例的运行结果："></a>加锁的懒汉式单例的运行结果：</h4><p>从运行结果可知，只创建了一个实例，内存地址是<code>0x7f28b00008c0</code>，所以加了互斥锁的普通懒汉式是线程安全的</p>
<h4 id="内部静态变量的懒汉单例的运行结果："><a href="#内部静态变量的懒汉单例的运行结果：" class="headerlink" title="内部静态变量的懒汉单例的运行结果："></a>内部静态变量的懒汉单例的运行结果：</h4><p><code>-std=c++0x</code>编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例，内存地址是<code>0x6016e8</code>，这个方式非常推荐，实现的代码最少！</p>
<h4 id="饿汉式单例的运行结果："><a href="#饿汉式单例的运行结果：" class="headerlink" title="饿汉式单例的运行结果："></a>饿汉式单例的运行结果：</h4><p>从运行结果可知，饿汉式在程序一开始就构造函数初始化了，所以本身就线程安全的</p>
<h4 id="特点与选择"><a href="#特点与选择" class="headerlink" title="特点与选择"></a>特点与选择</h4><ul>
<li>懒汉式是以时间换空间，适应于访问量较<strong>小</strong>时；推荐使用<strong>内部静态变量的懒汉单例</strong>，代码量少</li>
<li>饿汉式是以空间换时间，适应于访问量较<strong>大</strong>时，或者线程比较多的的情况</li>
</ul>
<p>如果你觉得文章还不错，记得”<strong>点赞关注</strong>“</p>
<p>关注我的微信公众号【 <strong>加班猿</strong> 】可以获取更多内容<br><img src="https://img-blog.csdnimg.cn/20201017112132917.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3ODI0MzU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/05/11/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">← Prev 常见面试题之计算机网络</a><span style="color: #fe2"> | </span><a href="/2021/05/11/C++%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%AF%AD%E8%A8%80/">C++常见面试题之基本语言 Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: 'Nq5lj4VJyzKxDJIKCQ8wQAWs-gzGzoHsz'
 , appKey: 'RSAaB7CGtQpU2kjI3iFgD7Rz'
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/coderhackett"> Dr.hackett</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">22</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">11</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">12</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1 说一下你熟悉的设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-C-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">2 C++单例模式总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">如何保证线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">什么是单例模式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">单例模式分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">单例类特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">2.6.</span> <span class="toc-text">普通懒汉式单例运行结果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">2.7.</span> <span class="toc-text">加锁的懒汉式单例的运行结果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E6%87%92%E6%B1%89%E5%8D%95%E4%BE%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">2.8.</span> <span class="toc-text">内部静态变量的懒汉单例的运行结果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">2.9.</span> <span class="toc-text">饿汉式单例的运行结果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">2.10.</span> <span class="toc-text">特点与选择</span></a></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>